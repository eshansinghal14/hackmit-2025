**Agent 4 Knowledge Nodes for: Data Structures**

1. **Interface ↔ Implementation Separation** – Every data structure should expose a clear *interface* (the set of supported operations, their signatures, and expected behavior) while hiding its *implementation* details (internal representation and algorithms). This abstraction enables interchangeable implementations, easier testing, and better modularity.  

2. **Efficient HashMap Traversal** – When iterating over a Java `HashMap`, using `entrySet()` with a `for‑each` loop (or an iterator) is markedly faster than iterating over `keySet()` and calling `get(key)` for each key. The `entrySet` provides direct access to key‑value pairs, avoiding extra hash look‑ups.  

3. **Union‑Find (Disjoint Set) Template** – A Union‑Find structure supports near‑constant‑time **find** (determine the representative of a set) and **union** (merge two sets). A typical implementation uses a `HashMap<Integer,Integer>` for parent links and optionally path‑compression/rank heuristics. This structure is essential for connectivity, Kruskal’s MST, and equivalence‑class problems.  

4. **Choosing the Right Structural Category** – Data structures fall into three practical categories:  
   *Linear* (arrays, linked lists, stacks, queues) – optimal for ordered, sequential access and simple insert/delete patterns.  
   *Hierarchical* (binary trees, BSTs, B‑trees, Red‑Black trees) – enable logarithmic search, ordered traversal, and balanced height guarantees.  
   *Complex* (hash tables, priority queues, graphs) – provide constant‑time look‑ups, ordered priority handling, or relationship modeling. Selecting a category aligns the data‑access pattern with performance goals.  

5. **Java Collections Framework Core Structures & When to Use Them** –  
   - **ArrayList** – fast random access (`O(1)`), slower insert/delete in middle (`O(n)`). Ideal for read‑heavy lists.  
   - **LinkedList** – constant‑time insert/delete at ends (`O(1)`), sequential access (`O(n)`). Best for frequent modifications.  
   - **HashMap / HashSet** – average‑case `O(1)` look‑ups, insert, delete. Use for key‑value mappings or deduplication.  
   - **Stack (Deque)** – LIFO operations (`push`, `pop`) in `O(1)`. Suitable for recursion, backtracking.  
   - **Queue (ArrayDeque, LinkedList)** – FIFO operations (`offer`, `poll`) in `O(1)`. Good for breadth‑first traversals, task scheduling.  

**Source Summary:**
- Sources Analyzed: 10 (31 – 40)
- Agent Coverage: 10 of 50 total sources